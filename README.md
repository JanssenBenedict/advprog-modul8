- Name: Janssen Benedict
- Class: Pemrograman Lanjut A
- NPM: 2306152102

# Module 08: High Level Networking - Reflection

### 1. What are the key differences between unary, server streaming, and bi-directional streaming RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable?
The key differences between the unary, server streaming, and bi-directional streaming RPC methods lie within how each RPC method handles client-server interactions, such as:
- The Unary RPC method handles client-server interactions by having the client send a single request and receive a single response from the server.
- The Server Streaming RPC method handles client-server interactions by having the client send a single request and receive multiple responses streamed from the server itself.
- The Bi-directional Streaming RPC method handles client-server interactions by having both the client and the server exchange streams of messages independently.
The scenarios in which each RPC method would be most suitable are:
- The Unary RPC method is most suitable in scenarios where simple one-time operations need to be executed (a single request needs to be made and a single response is needed in return), such as user authentication or other simple CRUD operations.
- The Server Streaming RPC method is most suitable in scenarios where the server needs to send a continuous stream of data, especially when dealing with data in large sets, such as sending constant updates or logging entries.
- The Bi-directional Streaming RPC method is most suitable in scenarios involving interactive communication at real-time where both the client and the server can send and receive messages simultaneously, such as live chat functions in applications.

### 2. What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?
- The potential security considerations involved in implementing a gRPC service in Rust regarding authentication consist of secure communication implementation between the client and the server. In order to achieve this, mTLS (Mutual Transport Layer Security) can be used to ensure that both the client and the server authenticate one another using digital certificates to verify their identities. This method is much more useful when compared to the standard TLS, where only one side presents the digital certificate and not both. In addition to that, token-based authentication mechanisms, like JWT (JSON Web Tokens), can be implemented to achieve stronger access control whenever requests are made to the gRPC service.
- The potential security considerations involved in implementing a gRPC service in Rust regarding authorization consist of making sure that properly authenticated users have the appropriate permissions to perform the specific actions needed only. To enforce this, RBAC (Role-Based Access Control) can be utilized to make sure different users have different privileges based on their roles. This can be implemented with interceptors to verify claims within tokens (like JWT) before users can receive access to certain functionalities.
- The potential security considerations involved in implementing a gRPC service in Rust regarding data encryption consist of proper sensitive data protection in transit and at rest. To protect data transferred over a network, the data must be encrypted in transit, this can be done by utilizing TLS encryption for communications between the client and the server. To protect sensitive data stored in the system, the data must be encrypted at rest, this can be done by utilizing specific encryption mechanisms (like AES-256) before storing the data or using specific extensions to manage encrypted data stored in databases (like pgcrypto for PostgreSQL databases). Key Management System tools could also be utilized to safely store important encryption keys (like AWS KMS, Google Cloud KMS, or HashiCorp Vault).

### 3. What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?
When handling bidirectional streaming in Rust gRPC, especially for scenarios such as chat applications, there are a few challenges that might arise, such as:
- Proper concurrency management: Bi-directional streaming in Rust gRPC involves both the client and the server exchanging multiple messages independently through a stream. However, due to Rust's asynchronous runtime, improper management of the tasks could lead to dangerous situations, such as deadlocks or race conditions. If proper handling of asynchronous operations isn't done, it could lead to cases where the asynchronous tasks meant to manage the chat system end up blocking one another.
- Flow control and backpressure: In a chat application, there might be cases where the sender ends up transmitting messages far too quickly, to the point where the receiver is overwhelmed and couldn't process them all in time. By default, gRPC utilizes HTTP/2, which includes built-in flow control mechanisms. However, at the application-level, backpressure mechanisms also need to be implemented. If not, it could lead to other issues, such as buffer overflows, severely increased memory usage, or even messages being dropped due to the large message buildup that might occur.
- Error handling and cancellation: Bi-directional streaming also involves possible errors occurring at both sides of the communication process. These errors consists of network failures, message processing issues, or other possible errors. These exceptions must be handled properly in order to prevent resource leaks, connection hanging, or system crashes. Proper error handling and cancellation could be done by sending error messages without disrupting the flow of communication, utilizing cancellation tokens to shut down communications gracefully, or cleaning up any held resources when a stream terminates.

### 4. What are the advantages and disadvantages of using the tokio_stream::wrappers::ReceiverStream for streaming responses in Rust gRPC services?
- Advantages: One of the advantages of using the tokio_stream::wrappers::ReceiverStream for streaming responses in Rust gRPC services is that the ReceiverStream allows easy integration of Rustâ€™s asynchronous channels (Tokio) with gRPC streams, allowing for simplified asynchronous communications. Another advantage is that it's concurrency friendly, as the sender can be cloned and shared across many tasks, allowing them all to push messages into the same stream independently. Additionally, it handles backpressure effectively by allowing the sender to properly await streaming responses when the receiver is overwhelmed. It also helps in cleaning up held resources when a stream terminates or a channel is closed, avoiding any possible resource leaks.
- Disadvantages: One of the disadvantages of using the tokio_stream::wrappers::ReceiverStream for streaming responses in Rust gRPC services is that stream control is fairly limited due to ReceiverStream simply being a thin wrapper around the Tokio mpsc::Receiver, which doesn't have the mechanisms needed for more advanced and complex streaming scenarios. Other than that, because ReceiverStream is just a thin wrapper, it doesn't provide any error handling mechanisms, thus resulting in harder error handling and custom error signaling implementations are necessary. And finally, for more simple use cases, like sending a known and finite collection of items that could be produced synchronously, setting up an mpsc channel and wrapping it in a ReceiverStream actually introduces unnecessary complexity.

### 5. In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time?


### 6. In the MyPaymentService implementation, what additional steps might be necessary to handle more complex payment processing logic?

### 7. What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?

### 8. What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?

### 9. How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?

### 10. What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?